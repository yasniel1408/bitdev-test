"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReactApp = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const toolbox_network_get_port_1 = require("@teambit/toolbox.network.get-port");
const component_1 = require("@teambit/component");
const dependency_resolver_1 = require("@teambit/dependency-resolver");
const lodash_1 = require("lodash");
const webpack_1 = require("@teambit/webpack");
const bit_error_1 = require("@teambit/bit-error");
const webpack_2 = __importDefault(require("webpack"));
const webpack_webpack_dev_server_1 = require("@teambit/webpack.webpack-dev-server");
const webpack_webpack_bundler_1 = require("@teambit/webpack.webpack-bundler");
const react_webpack_react_webpack_1 = require("@teambit/react.webpack.react-webpack");
const webpack_transformers_favicon_reload_1 = require("@teambit/webpack.transformers.favicon-reload");
const plugins_1 = require("./plugins");
const compute_results_1 = require("./compute-results");
const webpack_app_config_1 = require("./webpack/webpack.app.config");
const mutators_1 = require("./webpack/mutators");
const ssr_express_1 = require("./ssr/ssr-express");
class ReactApp {
    constructor(name, entry, ssr, portRange, logger, dependencyResolver, pubsub, workspacePath, prerender, bundler, ssrBundler, devServer, transformers = [], deploy, favicon) {
        this.name = name;
        this.entry = entry;
        this.ssr = ssr;
        this.portRange = portRange;
        this.logger = logger;
        this.dependencyResolver = dependencyResolver;
        this.pubsub = pubsub;
        this.workspacePath = workspacePath;
        this.prerender = prerender;
        this.bundler = bundler;
        this.ssrBundler = ssrBundler;
        this.devServer = devServer;
        this.transformers = transformers;
        this.deploy = deploy;
        this.favicon = favicon;
        this.applicationType = 'react-common-js';
        this.dir = 'public';
        this.ssrDir = 'ssr';
    }
    run(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const [from, to] = this.portRange;
            // @ts-ignore - remove this ts-ignore when bit 0.1.65 is out
            const port = context.port || (yield toolbox_network_get_port_1.Port.getPort(from, to));
            if (this.devServer) {
                yield this.devServer.listen(port);
                return port;
            }
            const devServerContext = yield this.getDevServerContext(context);
            const devServer = this.createDevServer(devServerContext, this.transformers);
            yield devServer.listen(port);
            return port;
        });
    }
    /**
     * create an instance of bit-compliant webpack dev server for a set of components
     */
    createDevServer(context, transformers = []) {
        var _a;
        const config = this.createDevServerConfig(context.entry, process.cwd(), context.id, context.rootPath, context.publicPath, context.title);
        const baseConfig = (0, react_webpack_react_webpack_1.configBaseFactory)(false);
        const baseDevConfig = (0, react_webpack_react_webpack_1.configBaseDevFactory)({
            workspaceDir: this.workspacePath,
        });
        const appDevConfig = (0, react_webpack_react_webpack_1.configAppDevFactory)();
        const reactBaseTransformer = () => new webpack_1.WebpackConfigMutator(config).merge([
            baseConfig,
            baseDevConfig,
            appDevConfig,
        ]);
        const transformerContext = Object.assign(context, { mode: 'dev' });
        const faviconFilename = this.favicon ? (0, path_1.basename)(this.favicon) : undefined;
        const options = {
            devServerContext: transformerContext,
            transformers: [
                reactBaseTransformer,
                ...transformers,
            ],
        };
        if (faviconFilename) {
            (_a = options.transformers) === null || _a === void 0 ? void 0 : _a.push((0, webpack_transformers_favicon_reload_1.faviconReload)(`/${faviconFilename}`));
        }
        return webpack_webpack_dev_server_1.WebpackDevServer.create(options, {
            logger: this.logger,
            pubsub: this.pubsub,
            workspacePath: this.workspacePath,
        });
    }
    runSsr(context) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const [from, to] = this.portRange;
            const port = yield toolbox_network_get_port_1.Port.getPort(from, to);
            // bundle client
            const clientBundle = yield this.buildClient(context);
            if (clientBundle.errors.length > 0)
                return { errors: clientBundle.errors };
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info('[react.application] [ssr] client bundle - complete');
            // bundle server
            const serverBundle = yield this.buildSsr(context);
            if (serverBundle.errors.length > 0)
                return { errors: serverBundle.errors };
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.info('[react.application] [ssr] server bundle - complete');
            // load server-side runtime
            const app = yield (0, ssr_express_1.loadSsrApp)(context.workdir, context.appName);
            (_c = this.logger) === null || _c === void 0 ? void 0 : _c.info('[react.application] [ssr] bundle code - loaded');
            const expressApp = (0, ssr_express_1.createExpressSsr)({
                name: context.appName,
                workdir: context.workdir,
                port,
                app,
                assets: (0, ssr_express_1.parseAssets)(clientBundle.assets),
                logger: this.logger,
            });
            expressApp.listen(port);
            return { port };
        });
    }
    buildClient(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const htmlConfig = [
                {
                    title: context.appName,
                    templateContent: (0, react_webpack_react_webpack_1.html)(context.appName),
                    minify: false,
                    favicon: this.favicon,
                },
            ];
            // extend, including prototype methods
            const ctx = Object.assign(Object.create(context), {
                html: htmlConfig,
                targets: [
                    {
                        entries: yield this.getEntries(),
                        components: [context.appComponent],
                        outputPath: (0, path_1.resolve)(context.workdir, (0, webpack_app_config_1.calcOutputPath)(context.appName, 'browser')),
                        hostDependencies: this.getHostDependencies(),
                        aliasHostDependencies: true,
                    },
                ],
                // @ts-ignore
                capsuleNetwork: undefined,
                previousTasksResults: [],
            });
            const bundler = this.createBundler(ctx, this.transformers);
            const bundleResult = yield bundler.run();
            return bundleResult[0];
        });
    }
    createBundler(context, transformers = [], initialConfigs, webpackInstance) {
        const baseConfig = (0, react_webpack_react_webpack_1.configBaseFactory)(true);
        const baseProdConfig = (0, react_webpack_react_webpack_1.configBaseProdFactory)(false);
        const reactBaseTransformer = (config) => {
            config.merge([baseConfig, baseProdConfig]);
            if (initialConfigs) {
                config.merge(initialConfigs);
            }
            return config;
        };
        const aspectContext = {
            logger: this.logger,
        };
        const bundler = webpack_webpack_bundler_1.WebpackBundler.create({
            bundlerContext: context,
            transformers: [reactBaseTransformer, ...transformers],
            targets: context.targets,
            webpackModulePath: webpackInstance || require.resolve('webpack'),
        }, aspectContext);
        return bundler;
    }
    buildSsr(context) {
        return __awaiter(this, void 0, void 0, function* () {
            // extend, including prototype methods
            const ctx = Object.assign(Object.create(context), Object.assign(Object.assign({}, context), { targets: [
                    {
                        entries: yield this.getSsrEntries(),
                        components: [context.appComponent],
                        outputPath: (0, path_1.resolve)(context.workdir, (0, webpack_app_config_1.calcOutputPath)(context.appName, 'ssr')),
                        hostDependencies: this.getHostDependencies(),
                        aliasHostDependencies: true,
                    },
                ], 
                // @ts-ignore
                capsuleNetwork: undefined, previousTasksResults: [] }));
            const bundler = this.createBundler(ctx, [(config) => config.merge([(0, webpack_app_config_1.ssrConfig)()]), ...this.transformers], undefined, webpack_2.default);
            const bundleResult = yield bundler.run();
            return bundleResult[0];
        });
    }
    build(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const htmlConfig = [
                {
                    title: context.name,
                    templateContent: (0, react_webpack_react_webpack_1.html)(context.name),
                    minify: false,
                    favicon: this.favicon,
                    // filename: ''.html`,
                },
            ];
            Object.assign(context, {
                html: htmlConfig,
            });
            const bundler = yield this.getBundler(context);
            const bundleResult = yield bundler.run();
            const ssrAppDir = (0, path_1.join)(this.getPublicDir(context.artifactsDir));
            if (this.ssr)
                yield this.buildSsrApp(context, ssrAppDir);
            return (0, compute_results_1.computeResults)(bundleResult, {
                publicDir: `${this.getPublicDir(context.artifactsDir)}/${this.dir}`,
                ssrPublicDir: ssrAppDir,
            });
        });
    }
    buildSsrApp(context, ssrAppDir) {
        return __awaiter(this, void 0, void 0, function* () {
            const ssrBundler = yield this.getSsrBundler(context);
            yield ssrBundler.run();
            const runner = (0, fs_1.readFileSync)((0, path_1.join)(__dirname, './ssr/app/runner')).toString();
            context.capsule.fs.writeFileSync((0, path_1.join)(ssrAppDir, 'runner.js'), runner);
            const capsuleSsrDir = context.capsule.fs.getPath(ssrAppDir);
            const installer = this.dependencyResolver.getInstaller({
                packageManager: 'teambit.dependencies/yarn',
                rootDir: capsuleSsrDir,
                cacheRootDirectory: capsuleSsrDir,
            });
            yield installer.install(capsuleSsrDir, this.getSsrPolicy(), new component_1.ComponentMap(new Map()));
            return ssrAppDir;
        });
    }
    getSsrPolicy() {
        const workspacePolicy = new dependency_resolver_1.WorkspacePolicy([]);
        workspacePolicy.add({
            lifecycleType: 'runtime',
            dependencyId: 'express',
            value: { version: '4.18.1' },
        });
        workspacePolicy.add({
            lifecycleType: 'runtime',
            dependencyId: '@teambit/react.rendering.ssr',
            value: { version: '0.0.3' },
        });
        workspacePolicy.add({
            lifecycleType: 'runtime',
            dependencyId: '@teambit/ui-foundation.ui.pages.static-error',
            value: { version: '0.0.87' },
        });
        workspacePolicy.add({
            lifecycleType: 'peer',
            dependencyId: 'react',
            value: { version: '17.0.2' },
        });
        workspacePolicy.add({
            lifecycleType: 'peer',
            dependencyId: 'react-dom',
            value: { version: '17.0.2' },
        });
        return workspacePolicy;
    }
    getBundler(context) {
        if (this.bundler)
            return this.bundler;
        return this.getDefaultBundler(context);
    }
    getSsrBundler(context) {
        if (this.ssrBundler)
            return this.ssrBundler;
        return this.getDefaultSsrBundler(context);
    }
    getDefaultBundler(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const { capsule } = context;
            const publicDir = this.getPublicDir(context.artifactsDir);
            const outputPath = (0, path_1.join)(capsule.path, publicDir);
            const bundlerContext = yield this.getBuildContext(context, { outputPath });
            const transformers = (0, lodash_1.compact)([
                (configMutator) => configMutator.merge((0, webpack_app_config_1.buildConfig)({ outputPath: (0, path_1.join)(outputPath, this.dir) })),
                (config) => {
                    if (this.prerender)
                        config.addPlugin((0, plugins_1.prerenderPlugin)(this.prerender));
                    return config;
                },
                (0, mutators_1.replaceTerserPlugin)({ prerender: !!this.prerender }),
                ...this.transformers,
            ]);
            const bundler = this.createBundler(bundlerContext, transformers);
            return bundler;
        });
    }
    getDefaultSsrBundler(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const { capsule } = context;
            const publicDir = this.getPublicDir(context.artifactsDir);
            const outputPath = (0, path_1.join)(capsule.path, publicDir);
            const bundlerContext = yield this.getBuildContext(context, { outputPath });
            const transformers = (0, lodash_1.compact)([
                (configMutator) => configMutator.merge((0, webpack_app_config_1.ssrBuildConfig)({ outputPath: (0, path_1.join)(outputPath, this.ssrDir) })),
                (0, mutators_1.replaceTerserPlugin)({ prerender: !!this.prerender }),
                ...this.transformers,
            ]);
            const bundler = this.createBundler(bundlerContext, transformers);
            return bundler;
        });
    }
    getBuildContext(context, { outputPath }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { capsule } = context;
            const reactEnv = context.env;
            const { distDir } = reactEnv.getCompiler();
            const targetEntries = yield this.getEntries(`${capsule.path}/${distDir}`);
            const entries = targetEntries.map((entry) => require.resolve(`${capsule.path}/${distDir}/${(0, path_1.basename)(entry)}`));
            const bundlerContext = Object.assign(context, {
                targets: [
                    {
                        components: [capsule === null || capsule === void 0 ? void 0 : capsule.component],
                        entries,
                        outputPath,
                        hostRootDir: capsule === null || capsule === void 0 ? void 0 : capsule.path,
                        hostDependencies: this.getHostDependencies(),
                        aliasHostDependencies: true,
                    },
                ],
                entry: [],
                rootPath: '/',
                metaData: {
                    initiator: `building app: ${context.name}`,
                    envId: context.id,
                },
            });
            return bundlerContext;
        });
    }
    getPublicDir(artifactsDir) {
        return (0, path_1.join)(artifactsDir, this.applicationType, this.name);
    }
    getEntries(path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (Array.isArray(this.entry))
                return this.entry;
            return this.entry(path);
        });
    }
    getSsrEntries() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.ssr)
                throw new bit_error_1.BitError('tried to build ssr without ssr entries');
            if (typeof this.ssr === 'string')
                return [this.ssr];
            return [yield this.ssr()];
        });
    }
    getDevServerContext(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const entries = yield this.getEntries();
            return Object.assign(context, {
                entry: entries,
                rootPath: '',
                publicPath: `public/${this.name}`,
                title: this.name,
                favicon: this.favicon,
                hostDependencies: this.getHostDependencies(),
                aliasHostDependencies: true,
            });
        });
    }
    getHostDependencies() {
        return ['react', 'react-dom'];
    }
    createDevServerConfig(entry, rootPath, devServerID, publicRoot, publicPath, title) {
        return (0, webpack_webpack_dev_server_1.configFactory)(devServerID, rootPath, entry, publicRoot, publicPath, this.pubsub, title, this.favicon);
    }
}
exports.ReactApp = ReactApp;
//# sourceMappingURL=react.application.js.map