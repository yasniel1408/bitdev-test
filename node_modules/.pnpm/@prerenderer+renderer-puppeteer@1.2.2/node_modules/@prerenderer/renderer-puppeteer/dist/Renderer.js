"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const promise_limit_1 = __importDefault(require("promise-limit"));
const puppeteer_1 = __importDefault(require("puppeteer"));
const Options_1 = require("./Options");
const waitForRender_1 = require("./waitForRender");
const schema_utils_1 = require("schema-utils");
const ts_deepmerge_1 = __importDefault(require("ts-deepmerge"));
class PuppeteerRenderer {
    constructor(options = {}) {
        (0, schema_utils_1.validate)(Options_1.schema, options, {
            name: 'Renderer Puppeteer',
            baseDataPath: 'options',
        });
        this.options = (0, ts_deepmerge_1.default)(Options_1.defaultOptions, options);
        if (options.renderAfterTime && this.options.timeout < options.renderAfterTime) {
            this.options.timeout = options.renderAfterTime + 1000;
        }
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            // Workaround for Linux SUID Sandbox issues.
            if (process.platform === 'linux') {
                if (!this.options.args)
                    this.options.args = [];
                if (this.options.args.indexOf('--no-sandbox') === -1) {
                    this.options.args.push('--no-sandbox');
                    this.options.args.push('--disable-setuid-sandbox');
                }
            }
            // Puppeteer tends to stay alive if the program exits unexpectedly, try to handle this and cleanup
            const cleanup = () => void this.destroy();
            process.on('SIGTERM', cleanup);
            process.on('SIGINT', cleanup);
            process.on('uncaughtException', cleanup);
            // Previously the whole option object was passed to `launch` which was not the best idea
            // We do a bit of backward compatibility here
            // TODO use an explicit list of legacyOptions rather than excluding the list of existing options
            /* eslint-disable @typescript-eslint/no-unused-vars */
            const _a = this.options, { maxConcurrentRoutes, inject, injectProperty, timeout, args, headless, pageSetup, pageHandler, consoleHandler, viewport, navigationOptions, launchOptions, renderAfterTime, renderAfterElementExists, elementHidden, elementVisible, skipThirdPartyRequests, renderAfterDocumentEvent } = _a, legacyOptions = __rest(_a, ["maxConcurrentRoutes", "inject", "injectProperty", "timeout", "args", "headless", "pageSetup", "pageHandler", "consoleHandler", "viewport", "navigationOptions", "launchOptions", "renderAfterTime", "renderAfterElementExists", "elementHidden", "elementVisible", "skipThirdPartyRequests", "renderAfterDocumentEvent"]);
            /* eslint-enable */
            if (!launchOptions) {
                if (Object.keys(legacyOptions).length > 1) {
                    console.warn('You are passing options to puppeteer launch using root options, which has been deprecated put them in "launchOptions" instead [Affected: ' + Object.keys(legacyOptions).join(',') + ']');
                }
            }
            this.puppeteer = yield puppeteer_1.default.launch(Object.assign({ headless: headless ? 'new' : false, args }, (launchOptions || legacyOptions)));
        });
    }
    handleRequestInterception(page, baseURL) {
        return __awaiter(this, void 0, void 0, function* () {
            yield page.setRequestInterception(true);
            page.on('request', (req) => {
                // Skip third party requests if needed.
                if (this.options.skipThirdPartyRequests) {
                    if (!req.url().startsWith(baseURL)) {
                        void req.abort();
                        return;
                    }
                }
                void req.continue();
            });
        });
    }
    renderRoutes(routes, prerenderer) {
        const rootOptions = prerenderer.getOptions();
        const baseURL = `http://${rootOptions.server.host}:${rootOptions.server.port}`;
        const limiter = (0, promise_limit_1.default)(this.options.maxConcurrentRoutes);
        return Promise.all(routes.map((route) => limiter(() => this.getPageContent(baseURL, route))));
    }
    getPageContent(baseURL, route) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = this.options;
            const page = yield this.puppeteer.newPage();
            try {
                if (options.consoleHandler) {
                    const handler = options.consoleHandler;
                    page.on('console', message => handler(route, message));
                }
                if (options.inject) {
                    yield page.evaluateOnNewDocument(`(function () { window['${options.injectProperty}'] = ${JSON.stringify(options.inject)}; })();`);
                }
                // Allow setting viewport widths and such.
                if (options.viewport)
                    yield page.setViewport(options.viewport);
                yield this.handleRequestInterception(page, baseURL);
                options.pageSetup && (yield options.pageSetup(page, route));
                // Hack just in-case the document event fires before our main listener is added.
                if (options.renderAfterDocumentEvent) {
                    yield page.evaluateOnNewDocument(waitForRender_1.listenForRender, options);
                }
                const navigationOptions = Object.assign({ waituntil: 'networkidle0', timeout: options.timeout }, options.navigationOptions);
                yield page.goto(`${baseURL}${route}`, navigationOptions);
                options.pageHandler && (yield options.pageHandler(page, route));
                const prs = [];
                // Wait for some specific element exists
                if (options.renderAfterElementExists) {
                    const elem = options.renderAfterElementExists;
                    prs.push((() => __awaiter(this, void 0, void 0, function* () {
                        try {
                            yield page.waitForSelector(elem, {
                                timeout: options.timeout,
                                hidden: options.elementHidden,
                                visible: options.elementVisible,
                            });
                        }
                        catch (e) {
                            yield page.close();
                            const timeS = Math.round(options.timeout / 100) / 10;
                            throw new Error(`Could not prerender: element '${elem}' did not appear within ${timeS}s`);
                        }
                    }))());
                }
                prs.push(page.evaluate(waitForRender_1.waitForRender, options));
                const res = yield Promise.race(prs);
                if (res) {
                    throw new Error(res);
                }
                const result = {
                    originalRoute: route,
                    route: yield page.evaluate('window.location.pathname'),
                    html: yield page.content(),
                };
                return result;
            }
            finally {
                yield page.close();
            }
        });
    }
    destroy() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.puppeteer) {
                yield this.puppeteer.close();
            }
        });
    }
}
exports.default = PuppeteerRenderer;
