"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ViteReact = void 0;
const find_root_1 = __importDefault(require("find-root"));
const builder_1 = require("@teambit/builder");
const fs_1 = require("fs");
const lodash_1 = require("lodash");
const toolbox_network_get_port_1 = require("@teambit/toolbox.network.get-port");
const workspace_1 = __importDefault(require("@teambit/workspace"));
const path_1 = require("path");
const vite_esm_packages_vite_1 = __importDefault(require("@teambit/vite.esm-packages.vite"));
const server_1 = require("./server");
class ViteReact {
    constructor(
    /**
     * name of the application.
     */
    name = 'react-vite', 
    /**
     * default port for the dev server and preview.
     */
    portRange = [3000, 3200], 
    /**
     * entries to include.
     */
    serverRoot = 'server.app-root', 
    /**
     * vit config. overrides default react config.
     */
    viteConfigPath = 'vite.config', 
    /**
     * use true to ignite vit in SSR mode.
     */
    ssr = false, 
    /**
     * name of the artifact.
     */
    artifactName = 'app-bundle', 
    /**
     * filename of the server.
     */
    serverFilename = 'server', 
    /**
     * the complication output dir to use.
     * change according to your env.
     * defaults to: `dist`
     */
    compileOutputDir = 'dist', 
    /**
     * build config for the vite build of the server side code.
     * used for both the express server, and the ssr.
     * defaults to cjs.
     */
    viteServerBuildConfigPath = 'vite-server.config.js', 
    /**
     * deploy function.
     */
    deploy, 
    /**
     * peer dependencies to alias from the app component dependencies.
     */
    peers = [], 
    /**
     * instance of vite.
     * uses the any type annotation to avoid type issues between versions. can be either a promise or a value.
     * @type typeof Vite
     */
    vite = (0, vite_esm_packages_vite_1.default)()) {
        this.name = name;
        this.portRange = portRange;
        this.serverRoot = serverRoot;
        this.viteConfigPath = viteConfigPath;
        this.ssr = ssr;
        this.artifactName = artifactName;
        this.serverFilename = serverFilename;
        this.compileOutputDir = compileOutputDir;
        this.viteServerBuildConfigPath = viteServerBuildConfigPath;
        this.deploy = deploy;
        this.peers = peers;
        this.vite = vite;
        this.defaultPeers = ['react', 'react-dom', 'graphql', 'react-router', 'react-router-dom', '@apollo/client'];
    }
    /**
     * run the dev server for a given context.
     * can run in both pwa or ssr modes.
     */
    run(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const vite = yield this.vite;
            const workspace = context.getAspect(workspace_1.default.id);
            const [fromPort, toPort] = this.portRange;
            const port = Number.isNaN(context.port)
                ? yield toolbox_network_get_port_1.Port.getPort(fromPort, toPort)
                : context.port;
            const rootComponentDir = context.hostRootDir;
            const appId = context.appComponent.id;
            const isInWorkspace = yield workspace.hasId(appId);
            const componentDir = isInWorkspace
                ? workspace === null || workspace === void 0 ? void 0 : workspace.componentDir(context.appComponent.id)
                : rootComponentDir;
            // const publicDir = join(componentDir, this.compileOutputDir);
            const publicDir = componentDir;
            const peers = this.peers.length ? this.peers : this.defaultPeers;
            const mode = 'development';
            const userConfig = yield this.loadViteConfig({
                mode,
                command: 'serve'
            }, componentDir, this.viteConfigPath);
            // TODO remove any after merging PR.
            const env = yield this.getEnvFile(mode, componentDir, context.envVariables);
            const viteConfig = yield this.computeConfig(componentDir, peers, rootComponentDir, userConfig, workspace, env);
            const devServer = yield vite.createServer(viteConfig);
            if (this.ssr) {
                const server = yield (0, server_1.createSsrServer)({
                    publicDir,
                    indexHtmlPath: (0, path_1.join)(componentDir, 'index.html'),
                    serverPath: (0, path_1.join)(componentDir, this.serverRoot),
                    serverEntryFile: (0, path_1.join)(publicDir, this.serverRoot),
                    dev: true,
                    viteServer: devServer,
                });
                server.listen(port);
                return {
                    appName: this.name,
                    port
                };
            }
            yield devServer.listen(port);
            devServer.printUrls();
            return {
                appName: this.name,
                port
            };
        });
    }
    getEnvFile(mode, rootDir, overrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const vite = yield this.vite;
            const dotenv = vite.loadEnv(mode, rootDir);
            return Object.assign(Object.assign({}, overrides), dotenv);
        });
    }
    findViteConfig(componentDir, configPath) {
        const searchStrings = [
            (0, path_1.join)(componentDir, configPath || this.viteConfigPath),
            (0, path_1.join)(componentDir, 'vite.config.mjs'),
            (0, path_1.join)(componentDir, 'vite-config')
        ];
        return searchStrings.find((searchStr) => {
            return (0, fs_1.existsSync)(searchStr);
        });
    }
    loadViteConfig(config, componentDir, path) {
        return __awaiter(this, void 0, void 0, function* () {
            const vite = yield this.vite;
            const configPath = this.findViteConfig(componentDir, path);
            const exists = (0, fs_1.existsSync)(configPath);
            if (!exists)
                return {};
            const viteConfig = yield vite.loadConfigFromFile(config, configPath);
            return viteConfig === null || viteConfig === void 0 ? void 0 : viteConfig.config;
        });
    }
    plugins(config) {
        const configPlugins = (config === null || config === void 0 ? void 0 : config.plugins) || [];
        // if (this.removeDefaultPlugins) return configPlugins;
        if (configPlugins.length)
            return configPlugins;
        return [];
    }
    computeConfig(root, peers = [], rootDir, config = {}, workspace, envVars = {}) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const components = workspace ? yield workspace.list() : [];
            const packageList = (0, lodash_1.compact)(components.map((c) => workspace === null || workspace === void 0 ? void 0 : workspace.componentPackageName(c)));
            const viteServerOptions = config.server || {};
            const watchOptions = viteServerOptions.watch || {};
            const optimizeDepsOpts = config.optimizeDeps || {};
            const resolveConfig = config.resolve || {};
            const aliases = ((_a = config === null || config === void 0 ? void 0 : config.resolve) === null || _a === void 0 ? void 0 : _a.alias) || {};
            const viteFsOptions = ((_b = config.server) === null || _b === void 0 ? void 0 : _b.fs) || {};
            const configSsr = config.ssr || {};
            let ignoredFromWatchOpts = [];
            if (watchOptions.ignored) {
                ignoredFromWatchOpts = Array.isArray(watchOptions.ignored) ? watchOptions.ignored : [watchOptions.ignored];
            }
            const ignored = packageList
                .map((p) => `!**/node_modules/${p}/**`)
                .concat(ignoredFromWatchOpts);
            const alias = peers.reduce((acc, peer) => {
                let filepath = '';
                try {
                    filepath = require.resolve(peer, { paths: [rootDir] });
                    acc[peer] = (0, find_root_1.default)(filepath);
                    return acc;
                }
                catch (err) {
                    return acc;
                }
            }, {});
            return Object.assign(Object.assign({ define: {
                    'process.env': JSON.stringify(Object.assign({}, envVars)),
                }, cacheDir: (0, path_1.join)(root, 'node_modules', '.vite') }, config), { configFile: false, 
                // envFile: false,
                root, optimizeDeps: Object.assign(Object.assign({}, optimizeDepsOpts), { exclude: packageList.concat(optimizeDepsOpts.exclude || []) }), ssr: Object.assign(Object.assign({}, configSsr), { noExternal: packageList }), server: Object.assign(Object.assign({}, viteServerOptions), { middlewareMode: this.ssr, watch: Object.assign(Object.assign({}, watchOptions), { ignored }), fs: Object.assign({}, viteFsOptions) }), resolve: Object.assign(Object.assign({ mainFields: ['source', 'main', 'module', 'jsnext:main', 'jsnext'] }, resolveConfig), { alias: (0, lodash_1.merge)(alias, aliases) }), plugins: this.plugins(config), appType: this.ssr ? 'custom' : undefined });
        });
    }
    computeBuildClientConfig(root, config = {}) {
        const buildConfig = config === null || config === void 0 ? void 0 : config.build;
        return Object.assign(Object.assign({}, config), { configFile: false, 
            // envFile: false,
            plugins: this.plugins(config), root, build: Object.assign(Object.assign({}, buildConfig), { emptyOutDir: false, outDir: (0, path_1.join)('..', this.outputDir) }) });
    }
    computeBuildConfig(root, input, outputFilename, config = {}) {
        var _a, _b;
        const outDir = (0, path_1.join)('..', this.outputDir);
        const resolveOpts = config.resolve || {};
        const buildOpts = config.build || {};
        const rollupOptions = ((_a = config.build) === null || _a === void 0 ? void 0 : _a.rollupOptions) || {};
        return Object.assign(Object.assign({}, config), { configFile: false, 
            // envFile: false,
            resolve: Object.assign({ mainFields: ['main', 'module', 'jsnext:main', 'jsnext'], extensions: ['.js', '.mjs', '.mts', '.ts', '.jsx', '.tsx', '.json'] }, resolveOpts), plugins: this.plugins(config), root, build: Object.assign(Object.assign({}, buildOpts), { emptyOutDir: false, commonjsOptions: {
                    ignoreDynamicRequires: true,
                    sourceMap: ((_b = buildOpts === null || buildOpts === void 0 ? void 0 : buildOpts.commonjsOptions) === null || _b === void 0 ? void 0 : _b.sourceMap) || false,
                }, rollupOptions: Object.assign({ input, output: {
                        entryFileNames: `${outputFilename}.js`,
                        chunkFileNames: `${outputFilename}-chunk.js`,
                        format: 'cjs',
                    } }, rollupOptions), ssr: this.ssr, outDir }) });
    }
    get outputDir() {
        return (0, path_1.join)(builder_1.CAPSULE_ARTIFACTS_DIR, this.artifactName);
    }
    /**
     * app build.
     * building three entries, one for the server
     */
    build(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const vite = yield this.vite;
            const root = context.capsule.path;
            const config = yield this.loadViteConfig({
                mode: 'production',
                command: 'build'
            }, root, this.viteConfigPath);
            const serverConfig = yield this.loadViteConfig({
                mode: 'production',
                command: 'build'
            }, root, this.viteServerBuildConfigPath);
            const viteConfig = this.computeBuildClientConfig(root, config);
            const viteSsrConfig = this.computeBuildConfig(root, (0, path_1.join)(root, this.serverRoot), 'server-ssr', config);
            const ssrRunner = this.computeBuildConfig(root, require.resolve('./server-runner'), this.serverFilename, serverConfig);
            const clientBuild = vite.build(viteConfig);
            const serverBuild = vite.build(viteSsrConfig);
            const ssrRunnerBuild = vite.build(ssrRunner);
            yield Promise.all([clientBuild, serverBuild, ssrRunnerBuild]);
            return {
                artifacts: [
                    {
                        name: this.artifactName,
                        globPatterns: [this.outputDir],
                    },
                ],
                metadata: {
                    publicDir: this.outputDir
                }
            };
        });
    }
    static from(options) {
        return new ViteReact(options.name, options.defaultPort, options.serverRoot, options.viteConfigPath, options.ssr, options.artifactName, options.serverFilename, options.compileOutputDir, options.viteServerBuildConfigPath, options.deploy, options.vite);
    }
}
exports.ViteReact = ViteReact;
//# sourceMappingURL=vite-react.js.map