import {
  AppBuildContext,
  AppBuildResult,
  AppContext,
  Application,
  ApplicationInstance,
  DeployFn,
} from '@teambit/application';
import findRoot from 'find-root';
import { CAPSULE_ARTIFACTS_DIR } from '@teambit/builder';
import { existsSync } from 'fs';
import { compact, merge } from 'lodash';
import { Port } from '@teambit/toolbox.network.get-port';
import WorkspaceAspect, { Workspace } from '@teambit/workspace';
import { join } from 'path';
import getVite from '@teambit/vite.esm-packages.vite';
import type { PluginOption, InlineConfig, AnymatchPattern, ConfigEnv } from 'vite';
import { createSsrServer } from './server';
import type { ViteReactAppOptions } from './vite-react-app-type';

export class ViteReact implements Application {
  constructor(
    /**
     * name of the application.
     */
    readonly name: string = 'react-vite',

    /**
     * default port for the dev server and preview.
     */
    readonly portRange: [number, number] = [3000, 3200],

    /**
     * entries to include.
     */
    readonly serverRoot: string = 'server.app-root',

    /**
     * vit config. overrides default react config.
     */
    readonly viteConfigPath: string = 'vite.config',

    /**
     * use true to ignite vit in SSR mode.
     */
    readonly ssr: boolean = false,
    
    /**
     * name of the artifact.
     */
    readonly artifactName: string = 'app-bundle',

    /**
     * filename of the server.
     */
    readonly serverFilename: string = 'server',

    /**
     * the complication output dir to use.
     * change according to your env.
     * defaults to: `dist`
     */
    readonly compileOutputDir = 'dist',

    /**
     * build config for the vite build of the server side code.
     * used for both the express server, and the ssr.
     * defaults to cjs.
     */
    readonly viteServerBuildConfigPath: string = 'vite-server.config.js',

    /**
     * deploy function.
     */
    readonly deploy?: DeployFn,

    /**
     * peer dependencies to alias from the app component dependencies.
     */
    readonly peers: string[] = [],

    /**
     * instance of vite. 
     * uses the any type annotation to avoid type issues between versions. can be either a promise or a value.
     * @type typeof Vite
     */
    readonly vite: any = getVite()
  ) {}

  readonly defaultPeers = ['react', 'react-dom', 'graphql', 'react-router', 'react-router-dom', '@apollo/client'];

  /**
   * run the dev server for a given context.
   * can run in both pwa or ssr modes.
   */
  async run(context: AppContext): Promise<ApplicationInstance> {
    const vite = await this.vite;
    const workspace = context.getAspect<Workspace>(WorkspaceAspect.id);
    const [fromPort, toPort] = this.portRange;
    const port = Number.isNaN(context.port)
      ? await Port.getPort(fromPort, toPort)
      : context.port;

    const rootComponentDir = context.hostRootDir!;
    const appId = context.appComponent.id;
    const isInWorkspace = await workspace.hasId(appId);
    const componentDir = isInWorkspace 
      ? workspace?.componentDir(context.appComponent.id) as string
      : rootComponentDir;
    // const publicDir = join(componentDir, this.compileOutputDir);
    const publicDir = componentDir;
    const peers = this.peers.length ? this.peers : this.defaultPeers;
    const mode = 'development';
    const userConfig = await this.loadViteConfig({
      mode,
      command: 'serve'
    }, componentDir, this.viteConfigPath);
    // TODO remove any after merging PR.
    const env = await this.getEnvFile(mode, componentDir, context.envVariables as any);
    const viteConfig = await this.computeConfig(componentDir, peers, rootComponentDir, userConfig, workspace, env);
    const devServer = await vite.createServer(viteConfig);

    if (this.ssr) {
      const server = await createSsrServer({
        publicDir,
        indexHtmlPath: join(componentDir, 'index.html'),
        serverPath: join(componentDir, this.serverRoot),
        serverEntryFile: join(publicDir, this.serverRoot),
        dev: true,
        viteServer: devServer,
      });

      server.listen(port);

      return {
        appName: this.name,
        port
      };
    }

    await devServer.listen(port);
    devServer.printUrls();

    return {
      appName: this.name,
      port
    };
  }

  async getEnvFile(mode: string, rootDir: string, overrides?: Record<string, string>) {
    const vite = await this.vite;
    const dotenv = vite.loadEnv(mode, rootDir);
    return {
      ...overrides,
      ...dotenv
    }
  }

  private findViteConfig(componentDir: string, configPath?: string): string {
    const searchStrings = [
      join(componentDir, configPath || this.viteConfigPath), 
      join(componentDir, 'vite.config.mjs'),
      join(componentDir, 'vite-config')
    ];

    return searchStrings.find((searchStr) => {
      return existsSync(searchStr);
    })
  }

  async loadViteConfig(config: ConfigEnv, componentDir: string, path: string) {
    const vite = await this.vite;
    const configPath = this.findViteConfig(componentDir, path);
    const exists = existsSync(configPath);
    if (!exists) return {};
    const viteConfig = await vite.loadConfigFromFile(config, configPath)
    return viteConfig?.config;
  }

  private plugins(config: InlineConfig): PluginOption[] {
    const configPlugins = config?.plugins || [];
    // if (this.removeDefaultPlugins) return configPlugins;
    if (configPlugins.length) return configPlugins;
    return [];
  }

  private async computeConfig(root: string, peers: string[] = [], rootDir: string, config: InlineConfig = {}, workspace?: Workspace, envVars: Record<string, string> = {}): Promise<InlineConfig> {
    const components = workspace ? await workspace.list() : [];
    const packageList = compact(
      components.map((c) => workspace?.componentPackageName(c))
    );
    const viteServerOptions = config.server || {};
    const watchOptions = viteServerOptions.watch || {};
    const optimizeDepsOpts = config.optimizeDeps || {};
    const resolveConfig = config.resolve || {};
    const aliases = config?.resolve?.alias || {};
    const viteFsOptions = config.server?.fs || {};
    const configSsr = config.ssr || {};
    let ignoredFromWatchOpts: AnymatchPattern[] = [];
    if (watchOptions.ignored){
      ignoredFromWatchOpts = Array.isArray(watchOptions.ignored) ? watchOptions.ignored : [watchOptions.ignored]
    } 
    const ignored: AnymatchPattern[] = (packageList
      .map((p) => `!**/node_modules/${p}/**`) as AnymatchPattern[])
      .concat(ignoredFromWatchOpts);

    const alias = peers.reduce((acc, peer) => {
      let filepath = '';
      try {
        filepath = require.resolve(peer, { paths: [rootDir] });
        acc[peer] = findRoot(filepath);
        return acc;
        } catch (err) {
        return acc;
      }
    }, {});

    return {
      define: {
        'process.env': JSON.stringify({
          ...envVars
        }),
      },
      cacheDir: join(root, 'node_modules', '.vite'),
      ...config,
      configFile: false,
      // envFile: false,
      root,
      optimizeDeps: {
        ...optimizeDepsOpts,
        exclude: packageList.concat(optimizeDepsOpts.exclude || []),
      },
      ssr: {
        ...configSsr,
        noExternal: packageList
      },
      server: {
        ...viteServerOptions,
        middlewareMode: this.ssr,
        watch: {
          ...watchOptions,
          ignored,
        },
        fs: {
          ...viteFsOptions,
        },
      },
      resolve: {
        mainFields: ['source', 'main', 'module', 'jsnext:main', 'jsnext'],
        ...resolveConfig,
        alias: merge(alias, aliases)
      },
      plugins: this.plugins(config),
      appType: this.ssr ? 'custom' : undefined,
    };
  }

  private computeBuildClientConfig(root: string, config: InlineConfig = {}): InlineConfig {
    const buildConfig = config?.build;

    return {
      ...config,
      configFile: false,
      // envFile: false,
      plugins: this.plugins(config),
      root,
      build: {
        ...buildConfig,
        emptyOutDir: false,
        outDir: join('..', this.outputDir),
      },
    };
  }

  private computeBuildConfig(
    root: string,
    input: string,
    outputFilename: string,
    config: InlineConfig = {}
  ): InlineConfig {
    const outDir = join('..', this.outputDir);
    const resolveOpts = config.resolve || {};
    const buildOpts = config.build || {};
    const rollupOptions = config.build?.rollupOptions || {};

    return {
      ...config,
      configFile: false,
      // envFile: false,
      resolve: {
        mainFields: ['main', 'module', 'jsnext:main', 'jsnext'],
        extensions: ['.js', '.mjs', '.mts', '.ts', '.jsx', '.tsx', '.json'],
        ...resolveOpts,
      },
      plugins: this.plugins(config),
      root,
      build: {
        ...buildOpts,
        emptyOutDir: false,
        commonjsOptions: {
          ignoreDynamicRequires: true,
          sourceMap: buildOpts?.commonjsOptions?.sourceMap || false,
        },
        rollupOptions: {
          input,
          output: {
            entryFileNames: `${outputFilename}.js`,
            chunkFileNames: `${outputFilename}-chunk.js`,
            format: 'cjs',
          },
          ...rollupOptions,
        },
        ssr: this.ssr,
        outDir,
      },
    };
  }

  private get outputDir() {
    return join(CAPSULE_ARTIFACTS_DIR, this.artifactName);
  }

  /**
   * app build.
   * building three entries, one for the server
   */
  async build(context: AppBuildContext): Promise<AppBuildResult> {
    const vite = await this.vite;
    const root = context.capsule.path;
    const config = await this.loadViteConfig({
      mode: 'production',
      command: 'build'
    }, root, this.viteConfigPath);

    const serverConfig = await this.loadViteConfig({
      mode: 'production',
      command: 'build'
    }, root, this.viteServerBuildConfigPath);

    const viteConfig = this.computeBuildClientConfig(root, config);
    const viteSsrConfig = this.computeBuildConfig(
      root,
      join(root, this.serverRoot),
      'server-ssr',
      config
    );
    const ssrRunner = this.computeBuildConfig(
      root,
      require.resolve('./server-runner'),
      this.serverFilename,
      serverConfig
    );

    const clientBuild = vite.build(viteConfig);
    const serverBuild = vite.build(viteSsrConfig);
    const ssrRunnerBuild = vite.build(ssrRunner);

    await Promise.all([clientBuild, serverBuild, ssrRunnerBuild]);

    return {
      artifacts: [
        {
          name: this.artifactName,
          globPatterns: [this.outputDir],
        },
      ],
      metadata: {
        publicDir: this.outputDir
      }
    };
  }

  static from(options: ViteReactAppOptions) {
    return new ViteReact(
      options.name,
      options.defaultPort,
      options.serverRoot,
      options.viteConfigPath,
      options.ssr,
      options.artifactName,
      options.serverFilename,
      options.compileOutputDir,
      options.viteServerBuildConfigPath,
      options.deploy,
      options.vite
    );
  }
}
