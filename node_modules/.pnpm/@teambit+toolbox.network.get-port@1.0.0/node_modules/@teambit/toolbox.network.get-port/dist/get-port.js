"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Port = void 0;
/* eslint-disable no-use-before-define */
//  based on : https://github.com/sindresorhus/get-port/blob/main/index.js
const net_1 = __importDefault(require("net"));
const locked_1 = require("./locked");
class Port {
    get(options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const lockedPorts = {
                old: new Set(),
                young: new Set(),
            };
            const portCheckSequence = function* (ports) {
                if (ports) {
                    yield* ports;
                }
                yield 0;
            };
            let ports;
            const releaseOldLockedPortsIntervalMs = 1000 * 15;
            // Lazily create interval on first use
            let interval;
            if (options) {
                ports = typeof options.port === 'number' ? [options.port] : options.port;
            }
            if (interval === undefined) {
                interval = setInterval(() => {
                    lockedPorts.old = lockedPorts.young;
                    lockedPorts.young = new Set();
                }, releaseOldLockedPortsIntervalMs);
                // Does not exist in some environments (Electron, Jest jsdom env, browser, etc).
                if (interval.unref) {
                    interval.unref();
                }
            }
            for (const port of portCheckSequence(ports)) {
                try {
                    if ((_a = options.usedPort) === null || _a === void 0 ? void 0 : _a.includes(port))
                        throw new locked_1.Locked(port);
                    let availablePort = yield this.getAvailablePort(Object.assign(Object.assign({}, options), { port })); // eslint-disable-line no-await-in-loop
                    while (lockedPorts.old.has(availablePort) || lockedPorts.young.has(availablePort)) {
                        if (port !== 0) {
                            throw new locked_1.Locked(port);
                        }
                        availablePort = yield this.getAvailablePort(Object.assign(Object.assign({}, options), { port })); // eslint-disable-line no-await-in-loop
                    }
                    lockedPorts.young.add(availablePort);
                    return availablePort;
                }
                catch (error) {
                    if (!['EADDRINUSE', 'EACCES'].includes(error.code) && !(error instanceof locked_1.Locked)) {
                        throw error;
                    }
                }
            }
            throw new Error('No available ports found');
        });
    }
    getAvailablePort(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const server = net_1.default.createServer();
                server.unref();
                server.on('error', reject);
                server.listen(options, () => {
                    const serverInfo = server.address();
                    server.close(() => {
                        // @ts-ignore
                        resolve(serverInfo === null || serverInfo === void 0 ? void 0 : serverInfo.port);
                    });
                });
            });
        });
    }
    makeRange(from, to) {
        if (!Number.isInteger(from) || !Number.isInteger(to)) {
            throw new TypeError('`from` and `to` must be integer numbers');
        }
        if (from < 1024 || from > 65535) {
            throw new RangeError('`from` must be between 1024 and 65535');
        }
        if (to < 1024 || to > 65536) {
            throw new RangeError('`to` must be between 1024 and 65536');
        }
        if (to < from) {
            throw new RangeError('`to` must be greater than or equal to `from`');
        }
        const generator = function* (f, t) {
            for (let port = f; port <= t; port += 1) {
                yield port;
            }
        };
        return generator(from, to);
    }
    static getPort(from, to, usedPort) {
        const port = new Port();
        const range = port.makeRange(from, to);
        return port.get({ port: range, usedPort });
    }
    static getPortFromRange(range, usedPort) {
        const port = new Port();
        const portsRange = typeof range === 'number' ? [range] : port.makeRange(range[0], range[1]);
        return port.get({ port: portsRange, usedPort });
    }
}
exports.Port = Port;
//# sourceMappingURL=get-port.js.map